% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/piecewise_interpolate_pulses.R
\name{piecewise_interpolate_pulses}
\alias{piecewise_interpolate_pulses}
\title{Piecewise interpolation of equally spaced pitch pulses}
\usage{
piecewise_interpolate_pulses(
  pitchtier_df,
  section_by = "is_nuclear",
  pulses_per_section,
  index_column = NULL,
  time_by = "timepoint_norm",
  .grouping = "file",
  .pitchval = "hz",
  .sort = TRUE,
  parallelize = FALSE
)
}
\arguments{
\item{pitchtier_df}{Pitchtier dataframe, output of \code{batch_process_pitchtiers}
and preferably with time normalization already applied}

\item{section_by}{Column name containing the section designations of the pitch contour}

\item{pulses_per_section}{An integer vector of how many points to use
for each section of the contour. This needs to have EITHER 1 value, which
is recycled for all sections OR as many values as there are sections. In the
latter case, it is HIGHLY RECOMMENDED that this vector is NAMED and in the
desired order of the sections. If the vector is unnamed, it will use the
names of the section in the order they appear in the data.}

\item{index_column}{String, column name containing numeric indices of each
interval to extract pulses from. This really needs to be provided if you have
two adjacent intervals that have the same label in the column \code{section_by}.
Without unique indices differentiating them, this function will treat them
as one "long" interval. If and only if you do not have this case present in
your data, then you do not need to provide this. Leave it as NULL if
you don't have the indices in your dataframe & the function will try to
assign numeric indices based on when the labels in \code{section_by} change. If
you do have them, but don't have the case previously described with adjacent
labeled intervals, still provide the column name to save computation time.}

\item{time_by}{Quoted column name containing the timepoints, defaults to
\code{"timepoint_norm"} (highly recommended to use \code{time_normalize} as a
preprocessing step beforehand). Note that the results will have new
time-normalized values with the same column name.}

\item{.grouping}{Quoted column name indexing the unique recordings, defaults
to \code{"file"}}

\item{.pitchval}{Quoted column name for which pitch values to use, defaults
to \code{"hz"}}

\item{.sort}{Logical, defaults to TRUE, whether to sort the dataframe
by the values in \code{time_by} for each group specified by \code{.grouping}. If your
dataframe is large, you should consider pre-sorting it before passing to this
function & set this to FALSE. The sorting is needed to ensure that the pulse
indices are in the correct order.}

\item{parallelize}{Logical, defaults to FALSE, whether to run in parallel via multisession
\code{furrr::future_map_dfr}}
}
\value{
Dataframe of interpolated pitch pulses by section
}
\description{
This is an extension of \code{interpolate_equal_pulses} which extracts equal pulses
within particular sections of a time series. This was written as a component of
\code{average_pitchtracks}, where I needed to extract equally spaced pulses
within prenuclear and nuclear regions separately so I could then take
averages within the sections. This function can also be useful if you
want a lower resolution for one section but a higher resolution for another.
}
\details{
Note that if you have two sections that share a boundary, you will get
two pulses at the same timepoint-- one associated with the end of the first
section, the other at the start of the second. If you plot the pulse indices
you'll encounter cases where there's no change from one pulse to another
at these shared timestamps. If you want to remove one of them, please refer
to \code{adjust_pulses()}.
}
